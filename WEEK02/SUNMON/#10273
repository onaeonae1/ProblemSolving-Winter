/**
 * RESULT: 
 * NAME: 고대 동굴 탐사
 * LINK: https://www.acmicpc.net/problem/10273
 * DATE: 2020-01-12 
 * AUTHOR: sunmon
 * TIP:
 * 1. 인접리스트 쓰기
 * 2. 초기화 잊지말것!!!
**/

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <string>
using namespace std;

stack<int> best, route;                 //최대 이익을 얻을 수 있는 경로, 일반 탐색하는 경로
vector<vector<pair<int,int> > >cave;    //인접리스트
vector<int> treasure;                   //동굴별 보물의 가치
int best_value;                         //최대 이익

//최대 이익을 얻는 best경로 저장
//dfs(현재 동굴, 현재까지의 가치, 현재까지 소요경비)
void dfs(int here, int value, int cost)
{
    route.push(here);
    for(int i = 0; i<cave[here].size(); i++)
    {
        pair<int,int>& there = cave[here][i];
        dfs(there.first, value+treasure[there.first], cost+there.second);
    }

    if(value-cost > best_value)
    {
        best = route;
        best_value = value-cost;
    }
    route.pop();
}

//전체 동굴 탐색
void dfsAll()
{
    //벡터, 전역변수 초기화
    best=stack<int>();
    route=stack<int>();
    best_value = -987654321;

    dfs(0, treasure[0], 0);
}

int main()
{
    int testcase;
    cin >> testcase;

    while(testcase--)
    {
        //동굴 정보 입력받기
        int N, E;
        cin >> N >> E;
        cave = vector<vector<pair<int,int> >>(N, vector<pair<int,int>>());
        treasure = vector<int>(N,-1);
        for(int i = 0; i<N; i++) 
            cin >> treasure[i];
        for(int i = 0; i<E; i++)
        {
            int from, to, cost; //현재 위치, 이동할 동굴, 이동 비용
            cin >> from >> to >> cost;
            cave[from-1].push_back({to-1, cost});
        }

        dfsAll();

        //정답 출력하기
        cout << best_value << " " <<  best.size() << endl;
        string r = "";
        while(!best.empty())
        {
            int n = best.top()+1;
            r += std::to_string(n);
            best.pop();
        }
        cout << r << endl;
    }

}
